/*
* 内置函数的总结
*/
TODO Apply 函数 调用者.apply
1、apply 函数返回类型，永远是'调用者'本身               TODO 此条和 also 一样
2、apply 函数的匿名函数里持有的 this == '调用者' 本身    TODO 此条和 run 一样

TODO let 函数 调用者.let
1、let 函数的返回类型，是根据匿名函数的最后一行变化而变化   TODO 此条和 run 一样
2、let 函数的匿名函数里持有的 it == '调用者' 本身        TODO 此条和 also 一样

TODO run 函数 调用者.run
1、run 函数的返回类型，是根据匿名函数的最后一行变化而变化  TODO 此条和 let 一样
2、run 函数的匿名函数里持有的 this == '调用者' 本身     TODO 此条和 apply 一样

TODO with with(调用者) with 和 run 基本一样，只是调用者不同
1、with 函数返回类型，是根据匿名函数最后一行变化而变化  TODO 此条和 let 一样
2、with 函数的函数里持有的 this == '调用者' 本身     TODO 此条和 apply 一样

TODO also 调用者.also
1、also 函数返回类型，永远是 '调用者'本身           TODO 此条和 apply 一样
2、also 函数的匿名函数里持有的 it == '调用者' 本身  TODO 此条和 let 一样

TODO takeif 内置函数
1、takeif : 返回值 是 true ，返回调用者本身
2、takeif : 返回值 是 false, 返回 null 函数
TODO takeif + 空合并操作符一起使用
'调用者'.takeif{}?:"空字符串"
TODO takeifunless 内置函数
1、takeifunless : 返回值 是 false , 返回调用者本身
2、takeifunless : 返回值 是 true ，返回 null


TODO ========================== apply 与 also ======================================
相同点：apply  与 also 返回类型一样，永远都返回调用者本身，匿名函数，最后一行无法作为返回值，不影响函数返回类型
不同点：apply 函数里 apply{ 持有this对象} ，also 函数里 also{ 持有 it 对象}
应用点：
     '调用者'.apply{...}.apply{...}.apply{...} 可以链式调用
     '调用者'.also{...}.also{...}.also{...}    可以链式调用

TODO =========================== run 与 let =====================================================
相同点：run 与 let 返回类型， 是一样的，都是根据匿名函数最后一行返回类型而决定，run 与 let 的返回类型(是根据匿名函数的最后一行返回类型决定)
不同点：run 函数里 run{ 持有 this 对象 } ，let 函数里 let{ 持有 it 对象}
应用点：
     '调用者'.run{...}
     '调用者'.let{...}

     '调用者'.run{ this == '调用者' 本身
          double
          float
          String
          Char
          Int
          Boolean
     }
     '调用者'.let{ it == '调用者' 本身
          double
          float
          String
          Char
          Int
          Boolean
     }

 TODO ==============================run 与 with ========================================
 相同点：with 与 run,let 的返回类型是一样的，都会根据匿名函数的最后一行的返回类型而决定
 不同点：run 函数 run{持有 this 对象}，let 函数 let{持有 it 对象}，with 函数 with{持有 this 对象}
 应用点：
       '调用者'.run{...}
       '调用者'.let{...}
       whit('调用者'){...}


 TODO ==================================let 与 apply 内部源码分析原理=======================
 // let 的返回类型是根据匿名函数的变化而变化(lambda 的返回类型变化而变化)
 // 匿名函数里面 持有的 it == I == '调用者'本身
 inline fun <I,O> I.let(lambda:(I) -> O) : O = lambda(this)

// apply 的返回类型永远都是 I(所以可以链式调用)，（lambda 的返回类型无变化，你写的是Unit,并且没有和 lambda 返回类型相关联）
// 匿名函数里持有的 this == I == '调用者' 本身
 inline fun <I> I.apply(lambda: I.() -> Unit):I = {
    lambda()
    return this
 }